\subsection{Incremental Satisfiability Solvers}
\label{bk-sat}
%%% Intro
This section will give a brief overview of the internals of incremental
satisifiability solvers that VSMT manipulates. The solver presented in this
paper only manipulates the underlying solver via an smtlib2
interface~\cite{BarFT-SMTLIB}, specifically using the \addcitation{for data.sbv}
Data.SBV haskell library.

% SMT Lib assertion stack description
Smtlib compliant incremental sat solvers store boolean formulae in a global
stack called an \textit{assertion-set stack}. An assertion includes variables,
definitions of variables, logical formulae and function symbols. For example,
all of the following are legal assertions that could be placed on an assertion
stack in a singleton stack respectively:

\begin{align*}
  x == True \\
  x \wedge y \geq \pi \\
  y + 2 * z == 1729
\end{align*}

The assertion-set stack can be manipulated via several functions in accordance
with the SMTLIB2 interface. For the sake of brevity we only focus on the most
important few here. The \textit{push} command takes an integer, $n$, and pushes
$n$ many empty assertion sets onto the assertion-set stack. Similary
\textit{pop} removes $n$ assertion sets from the assertion-set stack. The
\textit{assert} command takes any term, \textit{t}, that is of type
\textbf{Bool} and pushes it onto the assertion-set stack.

% statement about solver context
The assertion-set stack is used by the sat solver as a global context from which
to check for satisifiability. This allows the solver to add or remove
information from the solver context without the use of undefined variables or
shadowing~\cite{BarFT-SMTLIB}. When a call to \textit{check-sat} is made the
solver will look for a model that satisfies all the conjuction of all assertion
sets on the assertion-set stack. In this way one is able to manipulate and reuse
shared information in sat calls via the direct manipulation of the assertion-set
stack.